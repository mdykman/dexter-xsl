<?xml-stylesheet href="docster.html.xsl" type="text/xsl" ?>
<doc>
    <copyright>dexter (c) 2007, 2008 Michael Dykman 
Free for use under version 2.0 of the Artistic License.     
http://www.opensource.org/licences/artistic-license.php</copyright>

  <title>The Dexter API</title>
  <author>
    <![CDATA[Michael Dykman <michael@dykman.org>]]>
  </author>
  <overview>
    <para>The internals required to create user-defined descriptors</para>
  </overview>
  <references>
    <reference>
      <title>Dexter</title>
      <summary>An introduction to dexter and it's design philosophy.</summary>
      <url>index.xml</url>
    </reference>
    <reference>
      <title>The Case for XSL</title>
      <summary>Reflections on the pros and cons of using XSLT in
		the web application build process</summary>
      <url>case-for-xsl.xml</url>
    </reference>
    <reference>
      <title>Dexter User Guide</title>
      <summary>Reference material 
      needed to use dexter and dexterity to produce XSL stylesheets</summary>
      <url>dexter-user-guide.xml</url>
    </reference>
  </references>

  <section>
    <title>Properties</title>
    <overview><para>
	 Dexter maintains properties at two levels.  General properties are
	 maintained in dexter.properties. Each module maintains a private set
	 of properties in a seperate file. 
	 The default dexter.properties file is embedded in dexter.jar. 
	 When used at the command line, any property may be over-ridden 
	 be over-ridden via --define key=value
	 </para></overview>
    <chapter>
      <title>dexter.properties</title>
		<code><![CDATA[
 # attribute names to be treated as id attributes.
 dexter.node.id=id,ID

 # list the modules to be bootstrapped
 dexter.module=dexterity,didi

 # define the search path for external <modules>.properties files.
 dexter.module.path=
		]]></code>
      <para>
      the prefix is applied to all dexter-defined attribute names 
      before scanning. it provides a pseudo-namespace to isolate 
      dexter-defined attributes from the the valid attributes of 
      the XML source. It may be redefined at need.
      </para>
    </chapter>
    <chapter>
      <title>id attributes</title>
      <code>
        <![CDATA[
 dexter.node.id=id,ID
 ]]>
      </code>
      <para>
        Some XML operations require that a document has defined id attributes. As this property is typically 
        bestowed the DTD or schema for the XML format at hand, dexter uses this alternate mechanism. Scanning
        the source document for id attributes as defined in the properties file is the first phase of dexter's 
        transformation process.
      </para>
    </chapter>

    <chapter>
      <title>editors</title>
      <code><![CDATA[
 dexter.editors=ajax
  ]]></code>
      <para>
        The second phase of the transformation process is to scan for and execute editors which are defined 
        to be active in this property. It accepts a comma-delimited list of editor names. These names, 
        prefixed with the dexterity prefix, are scanned for and
        executed as they are found. More detail about editors can be found in later chapters.
      </para>
    </chapter>

    <chapter>
      <title>descriptors</title>
      <code><![CDATA[
 dexter.descriptors=ignore,env,uniq,sub,if,case,each,ccpy,value,attr,target,ghost
      ]]></code>
      <para>
        The third phase of the transformation process is to scan for and assemble descriptors which are defined
        to be active in this property. It accepts a comma-delimited list of descriptor names. These names, 
        prefixed with the dexterity prefix, are scanned for and assembled into an execution tree. The 
        descriptors are evaluated in the same order as they are specified in this property.  
        More detail about descriptors can be found in later chapters.  And by later, I mean they aren't 
        written yet.
      </para>
    </chapter>
    <chapter>
      <title>block descriptors</title>
      <code><![CDATA[
 dexter.block=case 
 dexter.block.case=default
      ]]></code>
      <para>
        Block descriptors take some special handling at assembly time. This property directs the dexter engine 
        to treat 'case' as a block descriptor with an (always) optional terminating attribute of 'default'. 
        A block is not required to have a terminating attribute.
      </para>
    </chapter>

    <chapter>
      <title>Implementation</title>
      <code><![CDATA[
 dexter.a.ajax=org.dykman.dexter.didi.AjaxAnchorEditor
 dexter.a.target=org.dykman.dexter.didi.AjaxCallerDescriptor

 dexter.a.ignore=org.dykman.dexter.dexterity.NullDescriptor 
 dexter.a.if=org.dykman.dexter.dexterity.TestDescriptor 
 dexter.a.case=org.dykman.dexter.dexterity.CaseDescriptor
 dexter.a.env=org.dykman.dexter.dexterity.EnvDescriptor 
 dexter.a.each=org.dykman.dexter.dexterity.SelectDescriptor 
 dexter.a.attr=org.dykman.dexter.dexterity.MapAttributeDescriptor 
 dexter.a.value=org.dykman.dexter.dexterity.MapNodeDescriptor
 dexter.a.ccpy=org.dykman.dexter.dexterity.CopyElementDescriptor 
 dexter.a.sub=org.dykman.dexter.dexterity.SubdocDescriptor 
 dexter.a.uniq=org.dykman.dexter.dexterity.UniqAttrDescriptor
 dexter.a.ghost=org.dykman.dexter.dexterity.GhostDescriptor 
      ]]></code>
      <para>Each attribute is explicitly associated with it's implementing class.</para>
    </chapter>
  </section>
  <section>
    <title>Descriptors</title>
    <overview><para>
    All Descriptors discussed in this section are defined in the package org.dykman.dexter.descriptor.
    </para></overview>
    <chapter>
         <title>Simple Path Macros</title>
         <para><![CDATA[
     All of the path macros in dexter's default configuration are 
     simple path macros implemented via the built-in 
	  org.dykman.dexter.base.SimplePathMacro. They are defined through
	  a property keyed by dexter.macro.def.<funcname> with a simple format 
	  string for a value.
     Two variables are pre-defined in the format string, $path and $arg.  
     The rest is interpreted as literal text and passed through to the XSL document. 
	  Not all path macros require an argument.
         ]]></para>
         <code><![CDATA[
 #simple path macros
dexter.macro.cmp-name=local-name($path) = "$arg"
dexter.macro.eq=string($path) = "$arg"
dexter.macro.name=local-name($path)
dexter.macro.text=$path/text()
dexter.macro.istext=$path/self::text()
dexter.macro.trim=normalize-space($path)
dexter.macro.count=count($path)
dexter.macro.lessthan=count($path) < $arg
dexter.macro.morethan=count($path) > $arg
dexter.macro.pos=$path/self::position()
dexter.macro.contains=contains($path,"$arg")
dexter.macro.starts-with=starts-with($path,"$arg")
         ]]></code>
       </chapter>
       <chapter>
         <title>The PathFunction Interface</title>
         <para><![CDATA[
   Should the simple path macro fail to provide the level of control your expression
   requires, it is a trivial task to implement the interface directly. A property keyed by 
   dexter.macro.class.<funcname> may then be specified with the fully qualified class
    name of the implementation.   The example shown is not enabled by default since the
	 SimplePathMacro assumed all my use cases.
         ]]></para>
         <code><![CDATA[
 dexterity.macro.class.sample=org.dykman.dexter.base.NameFunction
         ]]></code>
       </chapter>
  </section>
  <section>
    <title>Editors</title>
    <overview><para>Editors logically modify the source
  document before it is extracted to XML.</para></overview>
    <chapter>
      <title>Output Domain</title>
      <para>As editors are designed to modify the input document, they typically
      need to contain domains-specific knowledge of the target XML format. It is
      not really possible for editors to be XML-agnostic, as is required for membership
      is the dexterity base module.
      </para>
      <para>
      Editors are created by sub-classing org.dykman.dexter.base.AbstractDocumentEditor. 
      </para>      
      <para> 
  Editors may influence XSL transforms to generate
  invalid result documents from valid source files.  Much care must be taken
  when implementing editors to make sure that our actions are valid in the
  context of the output document.   
      </para>
      <para>
  The only editor implementations in this release are confined to the experimental
  didi module which is responsible for all XHTML-specific functions.
      </para>
    </chapter>
  </section>
  <section>
  <title>Embedding Dexter</title>
  <overview>
  </overview>
  <chapter>
  <title>The Dexter Object</title>
  <code><![CDATA[
  import org.dykman.dexter.Dexter;

  // uses the built in properties in org/dykman/dexter/dexter.properties
  Dexter dexter = new Dexter("UTF-8");
  // an alternative allows to user to specify custom properties
  // Dexter dexter = new Dexter("UTF-8",my-properties);

  dexter.setMediaType("text/html");
  dexter.setMethod("html");
  dexter.setIndent(true);
  ]]></code>
  <para>
  The Dexter object is created with a specified content-encoding and,
  optionally, a set of properties.  If properties are not specified,
  the built-in properties will be used. Only the UTF-8 character
  encoding has been explored so far.  The output 
  attributes which are demonstrated in the example are the default 
  values.  As in XSL, method may be one of "xml", "html" or "text".  
  MediaType may be any mime-type consistent with your source/result
  XML type.  These settings are passed along directly to the XSL 
  document; they do not influence dexter's behavior. 
  </para>
  <para><![CDATA[
  org.w3c.xml.Document objects with a DocType of XSLT are produced
  by passing org.w3c.xml.Document objects of any DocType to the method
  generateXSLT(Document source).  The result is typed Map<String,Document>
  which will always contain at least one entry. This method does not 
  create documents on disk.  When used at the command line, dexter uses an
  internal method which invokes a null transform.in order to output
  it to a stream.  If you have a means of providing prettier output, 
  go for it.
  ]]>
  </para>
  <code><![CDATA[
	Map<String, Document> results = dexter.generateXSLT(inputDocument);
  ]]></code>
  </chapter>
  </section>
 </doc>
